// Generated by CoffeeScript 1.10.0
(function() {
  var H, S, block, find, identity, isDefined, join, ref, sprintf,
    slice = [].slice;

  ref = require("fairmont"), find = ref.find, isDefined = ref.isDefined, identity = ref.identity;

  sprintf = require("sprintf");

  H = require("handlebars");

  S = require("swag");

  S.registerHelpers(H);

  join = function(d, array) {
    return array.join(d);
  };

  block = function(f) {
    return function() {
      var args, j, options;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), options = arguments[j++];
      if (options.fn != null) {
        return join("", f.apply(null, slice.call(args).concat([options.fn])));
      } else {
        return f.apply(null, slice.call(args).concat([identity]));
      }
    };
  };

  H.registerHelper({
    "let": function() {
      var args, j, options;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), options = arguments[j++];
      return options.fn(this, {
        data: options.data,
        blockParams: args
      });
    },
    values: block(function(object, f) {
      var key, results, value;
      results = [];
      for (key in object) {
        value = object[key];
        results.push(f(value));
      }
      return results;
    }),
    filter: block(function(property, value, objects, f) {
      var j, len, object, results;
      results = [];
      for (j = 0, len = objects.length; j < len; j++) {
        object = objects[j];
        if (object[property] === value) {
          results.push(f(object));
        }
      }
      return results;
    }),
    pluck: block(function(property, objects, f) {
      var j, len, object, results;
      results = [];
      for (j = 0, len = objects.length; j < len; j++) {
        object = objects[j];
        results.push(f(object[property]));
      }
      return results;
    }),
    join: function(delimiter, array) {
      return join(delimiter, array);
    },
    sprintf: function(format, string) {
      return sprintf(format, string);
    },
    indent: function(n, string) {
      var indent;
      indent = " ".repeat(n);
      return string.replace(/\n/g, "\n" + indent);
    },
    hang: (function() {
      var indent;
      indent = function(x, s) {
        return (" ".repeat(x)) + s;
      };
      return function(i, w, s) {
        var first, line, m, ref1, rest;
        m = w - i;
        ref1 = s.match(RegExp(".{1," + m + "}(\\s+|$)", "g")), first = ref1[0], rest = 2 <= ref1.length ? slice.call(ref1, 1) : [];
        return [first].concat(slice.call(((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = rest.length; j < len; j++) {
              line = rest[j];
              results.push(indent(i, line));
            }
            return results;
          })()))).join("\n");
      };
    })(),
    json: function(value) {
      return JSON.stringify(value, null, 2);
    },
    match: block(function(re, s, f) {
      var j, k, len, results, v;
      if ((k = s.match(new RegExp(re, "g")))) {
        results = [];
        for (j = 0, len = k.length; j < len; j++) {
          v = k[j];
          results.push(f(v));
        }
        return results;
      } else {
        return [];
      }
    }),
    replace: function(re, r, s) {
      return s.replace(new RegExp(re, "g"), r);
    },
    pick: function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.find(isDefined);
    },
    parsePath: block(function(s, f) {
      var j, len, p, ref1, results;
      ref1 = ["/"].concat(slice.call(s.split("/").slice(1)));
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        p = ref1[j];
        results.push(f(p));
      }
      return results;
    })
  });

  module.exports = function(template, context) {
    return (H.compile(template, {
      noEscape: true
    }))(context);
  };

}).call(this);
